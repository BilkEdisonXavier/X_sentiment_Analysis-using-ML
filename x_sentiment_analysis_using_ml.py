# -*- coding: utf-8 -*-
"""X Sentiment analysis using ML.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PfHpbxul3qSi0W4kfvSPQN1fsCw0pR8S
"""

#install kaggle library
!pip install kaggle

"""upload my kaggle.json file

"""

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

"""import X sentiment dataset

"""

#API to fetch the dataset from kaggle
!kaggle datasets download -d kazanova/sentiment140

#extracting the compressed dataset

from zipfile import ZipFile
dataset = '/content/sentiment140.zip'

with ZipFile(dataset,'r') as zip:
  zip.extractall()
  print('The dataset is extracted')

#import libraries

import pandas as pd
import numpy as np
import re
from nltk.corpus import stopwords
from nltk.stem.porter import PorterStemmer
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score,confusion_matrix,classification_report

import nltk
nltk.download('stopwords')

print(stopwords.words('english'))

"""data processing"""

#load data
data = pd.read_csv('/content/training.1600000.processed.noemoticon.csv', encoding='ISO-8859-1')

data

#check rows and columns
data.shape

#print first 5 rows

data.head()

#naming the columns and reading the dataset again
columns_name = ['target','ids','date','flag','user','text']
data = pd.read_csv('/content/training.1600000.processed.noemoticon.csv', encoding='ISO-8859-1', names=columns_name)

#check rows and columns
data.shape

#print first 5 rows
data.head()

#counting num of missing values in dataset
data.isnull().sum()

#checking the distribution of target column
data['target'].value_counts()

"""convert the target"4"to"1"
"""

data.replace({'target':{4:1}},inplace=True)

data['target'].value_counts()

"""0-negative tweet,
1-positive tweet
"""

#stemming is the process of reducing a word to its root word
port_stem = PorterStemmer()

def stemming(content):
    stemmed_content = re.sub('[^a-zA-Z]',' ',content)
    stemmed_content = stemmed_content.lower()
    stemmed_content = stemmed_content.split()
    stemmed_content = [port_stem.stem(word) for word in stemmed_content if not word in stopwords.words('english')]
    stemmed_content = ' '.join(stemmed_content)
    return stemmed_content

data['stemmed_content'] = data['text'].apply(stemming) #atleast 50 minutes to complete this execution

data.head()

print(data['stemmed_content'])

print(data['target'])

#separating the data and lable
x = data['stemmed_content'].values
y = data['target'].values

print(x)

print(y)

"""spliting the data to training data and testing data"""

x_train,x_test,y_train,y_test = train_test_split(x,y,test_size=0.2,stratify=y,random_state=2)

print(x.shape,x_train.shape,x_test.shape)

print(x_train)

print(x_test)

# converting the textual(object) data to numerical(int) data

vectorizer = TfidfVectorizer()

x_train = vectorizer.fit_transform(x_train)
x_test = vectorizer.transform(x_test)

print(x_train)

print(x_test)

"""Training the **Machine** **Learning** model"""

#1)Logistic Regression

model = LogisticRegression(max_iter=1000)
model.fit(x_train,y_train)

#model evaluation
#accurracy score on training data
x_train_prediction = model.predict(x_train)
training_data_accuracy = accuracy_score(x_train_prediction,y_train)

print('Accuracy score of the training data : ', training_data_accuracy)

#accurracy score on testing data
x_test_prediction = model.predict(x_test)
testing_data_accuracy = accuracy_score(x_test_prediction,y_test)

print('Accuracy score of the testing data : ', testing_data_accuracy)

"""Model accuracy = 77.6%

saving the trained model
"""

import pickle

file_name = 'trained_model.sav'
pickle.dump(model,open(file_name,'wb'))

"""using the save model for future predictions"""

#loading the saved model
loaded_model = pickle.load(open("/content/trained_model.sav",'rb'))

x_new = x_test[200]
print(y_test[200])

prediction = loaded_model.predict(x_new)
print(prediction)

if (prediction[0]==0):
  print('Negative Tweet')
else:
  print('Positive Tweet')

x_new = x_test[2]
print(y_test[2])

prediction = loaded_model.predict(x_new)
print(prediction)

if (prediction[0]==0):
  print('Negative Tweet')
else:
  print('Positive Tweet')